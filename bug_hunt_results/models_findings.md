# Bug Hunt: Models Module

## Confirmed Bugs

### 1. CELResponse Lacks Consistency Validation

**File:** `/home/user/api-parity/api_parity/models.py` (lines 487-496)

**Issue:** The `CELResponse` model allows semantically invalid combinations of fields. The `ok`, `result`, and `error` fields have logical relationships that are not enforced:

- When `ok=True`, `result` should have a value and `error` should be None
- When `ok=False`, `error` should have a value and `result` should be None

**Evidence:**
```python
# All of these are accepted but are semantically invalid:
CELResponse(id="x", ok=True, result=True, error="oops")   # Contradictory!
CELResponse(id="x", ok=True, result=None, error=None)     # ok=True but no result!
CELResponse(id="x", ok=False, result=True, error=None)    # ok=False but has result!
CELResponse(id="x", ok=False, result=None, error=None)    # ok=False but no error!
```

**Impact:** Medium. The production code (`cel_evaluator.py`) does not use this model for validation - it parses JSON directly. However, if code ever relies on this model for deserialization, invalid data could slip through.

**Fix:** Add a model_validator:
```python
@model_validator(mode="after")
def check_consistency(self) -> Self:
    if self.ok:
        if self.result is None:
            raise ValueError("CELResponse with ok=True must have a result")
        if self.error is not None:
            raise ValueError("CELResponse with ok=True cannot have an error")
    else:
        if self.error is None:
            raise ValueError("CELResponse with ok=False must have an error")
        if self.result is not None:
            raise ValueError("CELResponse with ok=False cannot have a result")
    return self
```

---

### 2. ComparisonResult Lacks match/mismatch_type Consistency Validation

**File:** `/home/user/api-parity/api_parity/models.py` (lines 325-338)

**Issue:** The `ComparisonResult` model allows semantically invalid combinations:

- When `match=True`, `mismatch_type` should be None
- When `match=False`, `mismatch_type` should be set

**Evidence:**
```python
# Both of these are accepted but are semantically invalid:
ComparisonResult(match=True, mismatch_type=MismatchType.BODY, summary="test", details={...})
ComparisonResult(match=False, mismatch_type=None, summary="test", details={...})
```

**Impact:** Medium. The `Comparator` class always creates these correctly, but if bundles are hand-edited or created by other tools, invalid data could be loaded.

**Fix:** Add a model_validator:
```python
@model_validator(mode="after")
def check_match_consistency(self) -> Self:
    if self.match and self.mismatch_type is not None:
        raise ValueError("ComparisonResult with match=True cannot have mismatch_type")
    if not self.match and self.mismatch_type is None:
        raise ValueError("ComparisonResult with match=False must specify mismatch_type")
    return self
```

---

### 3. ComponentResult Lacks match/differences Consistency Validation

**File:** `/home/user/api-parity/api_parity/models.py` (lines 305-313)

**Issue:** The `ComponentResult` model's docstring states "empty if match=True" for differences, but this is not enforced.

**Evidence:**
```python
# This is accepted but violates the documented invariant:
ComponentResult(
    match=True,
    differences=[FieldDifference(path="$.test", target_a=1, target_b=2, rule="exact_match")]
)
```

**Impact:** Low. The `Comparator` always creates these correctly using `match=len(differences) == 0`, but the model should enforce its documented invariants.

**Fix:** Add a model_validator:
```python
@model_validator(mode="after")
def check_match_consistency(self) -> Self:
    if self.match and self.differences:
        raise ValueError("ComponentResult with match=True cannot have differences")
    return self
```

---

## Likely Bugs

### 4. MismatchMetadata Timestamp Validation Only Checks Format, Not Semantics

**File:** `/home/user/api-parity/api_parity/models.py` (lines 364-392)

**Issue:** The timestamp regex validates ISO 8601 format but allows semantically invalid dates:

**Evidence:**
```python
# All of these are accepted:
"2026-02-30T12:00:00"  # Feb 30 doesn't exist
"2026-13-01T12:00:00"  # Month 13 doesn't exist
"2026-01-32T12:00:00"  # Day 32 doesn't exist
"2026-01-01T25:00:00"  # Hour 25 doesn't exist
"9999-99-99T99:99:99"  # Completely invalid
```

**Impact:** Low. These timestamps would never be generated by the tool itself (it uses `datetime.isoformat()`), and invalid dates in artifacts are unlikely. However, if someone manually creates bundles with invalid timestamps, they would be accepted.

**Fix:** Use `datetime.fromisoformat()` for validation:
```python
@field_validator("timestamp")
@classmethod
def validate_timestamp(cls, v: str) -> str:
    try:
        datetime.fromisoformat(v.replace("Z", "+00:00"))
    except ValueError:
        raise ValueError(f"Invalid ISO 8601 timestamp: {v!r}")
    return v
```

---

## Suspicious Code

### 5. FieldRule Does Not Validate Required Parameters for Predefined Rules

**File:** `/home/user/api-parity/api_parity/models.py` (lines 163-201)

**Issue:** The `FieldRule` model accepts predefined rule names without their required parameters:

```python
FieldRule(predefined="numeric_tolerance")        # Missing 'tolerance' param!
FieldRule(predefined="epoch_seconds_tolerance")  # Missing 'seconds' param!
FieldRule(predefined="both_in_range")            # Missing 'min' and 'max' params!
```

**Analysis:** This is likely intentional - parameter validation happens in `RulesExpander` where the comparison library is available. The model just stores the data; the expander validates it against known predefined rules.

**Recommendation:** Document this design decision. Consider adding a note to the FieldRule docstring:
```
Note: Parameter requirements for predefined rules are validated at rule expansion
time, not at model construction. This allows the model to be constructed before
the comparison library is loaded.
```

---

### 6. Orphan Parameters Allowed in FieldRule

**File:** `/home/user/api-parity/api_parity/models.py` (lines 163-201)

**Issue:** Parameters can be specified without a corresponding predefined rule:

```python
FieldRule(tolerance=0.01)  # tolerance with no predefined rule to use it
FieldRule(presence=PresenceMode.REQUIRED, min=0, max=100)  # params but no predefined
```

**Analysis:** This is harmless but could indicate user error. The parameters would simply be ignored.

**Recommendation:** Could add a warning or validation, but low priority.

---

## Missing Test Coverage

### High Priority

1. **CELResponse inconsistent state combinations** - No tests for `ok=True` with `error`, `ok=False` with `result`, or missing required fields based on `ok` value.

2. **ComparisonResult inconsistent match/mismatch_type** - No tests for `match=True` with `mismatch_type` set, or `match=False` without `mismatch_type`.

3. **ComponentResult inconsistent match/differences** - No tests for `match=True` with non-empty differences.

### Medium Priority

4. **FieldRule with missing required parameters** - No tests verify that predefined rules without required params are accepted at model level (validation happens at expansion).

5. **MismatchMetadata with semantically invalid timestamps** - No tests for dates like Feb 30, Month 13, Hour 25.

6. **RequestCase/ResponseCase with edge-case body values** - No tests for `body=0`, `body=False`, `body=""`, `body=[]` (empty collections). These work correctly but should have explicit test coverage.

### Low Priority

7. **Negative values for fields that should be positive** - No tests for negative `elapsed_ms`, negative `step_index`, negative `status_code`.

8. **Empty chain (ChainCase with empty steps list)** - Not tested whether this is valid or should be rejected.

9. **CELResponse.result type coercion** - No tests for what happens if the Go subprocess returns a non-boolean result.
